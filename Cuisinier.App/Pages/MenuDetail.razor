@page "/menu/{MenuId:int}"
@attribute [Microsoft.AspNetCore.Authorization.Authorize]
@using Cuisinier.App.Components
@using Cuisinier.App.Services
@using Cuisinier.Shared.DTOs
@using MudBlazor
@using Microsoft.AspNetCore.SignalR.Client
@inject IMenuApi MenuApi
@inject IShoppingListApi ShoppingListApi
@inject IFavoriteApi FavoriteApi
@inject NavigationManager Navigation
@inject IConfiguration Configuration
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@implements IAsyncDisposable

<PageTitle>Détails du menu</PageTitle>

@if (_loading)
{
    <MudProgressLinear Color="Color.Primary" Indeterminate="true" />
}

@if (_menu != null)
{
    var menuTitle = $"Menu - Semaine du {_menu.WeekStartDate:dd/MM/yyyy}";
    <PageHeader Title="@menuTitle" />

    <MudGrid>
        @foreach (var recipe in _menu.Recipes)
        {
            <MudItem xs="12" md="6" lg="4">
                <RecipeCard 
                    Recipe="recipe" 
                    ShowDetails="true"
                    ShowActions="@_menuValid"
                    ShowFavoriteButton="@_menuValid"
                    IsFavorite="@(_favoriteStatus.GetValueOrDefault(recipe.Id, false))"
                    OnDelete="DeleteRecipe"
                    OnToggleCooked="ToggleRecipeCooked"
                    MenuValid="@_menuValid"
                    IsGenerating="@IsGenerating(recipe.Id)" />
            </MudItem>
        }
        @if (_menuValid)
        {
            <MudItem xs="12" md="6" lg="4">
                <AddFavoriteCard OnAddClick="OpenAddFavoriteDialog" />
            </MudItem>
        }
    </MudGrid>

    <MudStack Row="true" Spacing="2" Class="mt-4">
        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="() => ViewShoppingList(_menu.Id)">Voir la liste de courses</MudButton>
    </MudStack>
}

@code {
    [Parameter] public int MenuId { get; set; }

    private MenuResponse? _menu;
    private bool _loading = true;
    private bool _menuValid = false;
    private HubConnection? _hubConnection;
    private Dictionary<int, bool> _recipesBeingGenerated = new();
    private Dictionary<int, bool> _favoriteStatus = new();
    private int? _lastConnectedMenuId = null;

    protected override async Task OnInitializedAsync()
    {
        await LoadMenu();
        // Connect to the hub only if recipes are being generated
        if (_menuValid && HasRecipesBeingGenerated())
        {
            await InitializeSignalR();
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        // If MenuId changes, reload the menu and reconnect SignalR if necessary
        if (_menu?.Id != MenuId)
        {
            await LoadMenu();
            if (_menuValid && HasRecipesBeingGenerated())
            {
                await InitializeSignalR();
            }
        }
    }

    private bool HasRecipesBeingGenerated()
    {
        return _menu?.Recipes.Any(r => string.IsNullOrEmpty(r.DetailedRecipe)) == true;
    }

    private async Task InitializeSignalR()
    {
        // Close existing connection if it exists
        if (_hubConnection is not null)
        {
            try
            {
                await _hubConnection.StopAsync();
                await _hubConnection.DisposeAsync();
            }
            catch
            {
                // Ignore errors during shutdown
            }
            _hubConnection = null;
        }

        var apiBaseUrl = Configuration["ApiBaseUrl"] ?? Navigation.BaseUri;
        var hubUrl = $"{apiBaseUrl.TrimEnd('/')}/recipeHub";

        _hubConnection = new HubConnectionBuilder()
            .WithUrl(hubUrl)
            .WithAutomaticReconnect()
            .Build();

        _hubConnection.On<RecipeResponse>("RecipeDetailedGenerated", (recipe) =>
        {
            if (_menu != null)
            {
                var index = _menu.Recipes.FindIndex(r => r.Id == recipe.Id);
                if (index >= 0)
                {
                    _menu.Recipes[index] = recipe;
                    _recipesBeingGenerated[recipe.Id] = false;
                    InvokeAsync(StateHasChanged);
                }
            }
        });

        _hubConnection.On<int>("RecipeGenerationError", (recipeId) =>
        {
            _recipesBeingGenerated[recipeId] = false;
            InvokeAsync(StateHasChanged);
        });

        // Handle reconnection - refetch data after reconnecting
        _hubConnection.Reconnected += async (connectionId) =>
        {
            try
            {
                await _hubConnection.SendAsync("JoinMenuGroup", MenuId);
                await InvokeAsync(async () =>
                {
                    await RefreshRecipesState();
                    StateHasChanged();
                });
            }
            catch
            {
                // Ignore reconnection errors
            }
        };

        try
        {
            await _hubConnection.StartAsync();
            await _hubConnection.SendAsync("JoinMenuGroup", MenuId);
            _lastConnectedMenuId = MenuId;

            // After joining, refetch to catch any updates we might have missed
            await RefreshRecipesState();
        }
        catch
        {
            Snackbar.Add($"Erreur de connexion SignalR. Veuillez réessayer.", Severity.Error);
            _lastConnectedMenuId = null;
        }
    }

    private async Task RefreshRecipesState()
    {
        try
        {
            var freshMenu = await MenuApi.GetMenuAsync(MenuId);
            if (freshMenu != null && _menu != null)
            {
                foreach (var freshRecipe in freshMenu.Recipes)
                {
                    var index = _menu.Recipes.FindIndex(r => r.Id == freshRecipe.Id);
                    if (index >= 0)
                    {
                        // Update recipe if it now has DetailedRecipe
                        if (!string.IsNullOrEmpty(freshRecipe.DetailedRecipe))
                        {
                            _menu.Recipes[index] = freshRecipe;
                            _recipesBeingGenerated[freshRecipe.Id] = false;
                        }
                    }
                }
            }
        }
        catch
        {
            // Ignore refresh errors
        }
    }

    private bool IsGenerating(int recipeId)
    {
        // If the recipe is in the dictionary and marked as being generated
        if (_recipesBeingGenerated.ContainsKey(recipeId))
        {
            return _recipesBeingGenerated[recipeId];
        }
        
        // If the recipe has no DetailedRecipe and the menu is validated, display the skeleton
        if (_menu != null && _menuValid)
        {
            var recipe = _menu.Recipes.FirstOrDefault(r => r.Id == recipeId);
            return recipe != null && string.IsNullOrEmpty(recipe.DetailedRecipe);
        }
        
        return false;
    }

    private async Task LoadMenu()
    {
        try
        {
            _loading = true;
            _menu = await MenuApi.GetMenuAsync(MenuId);
            
            // Check if the menu has been validated (if a shopping list exists)
            _menuValid = await VerifyMenuValid();
            
            // Reset and rebuild the dictionary based on current recipe state
            _recipesBeingGenerated.Clear();
            _favoriteStatus.Clear();
            
            // Mark recipes without DetailedRecipe as being generated
            if (_menu != null && _menuValid)
            {
                foreach (var recipe in _menu.Recipes.Where(r => string.IsNullOrEmpty(r.DetailedRecipe)))
                {
                    _recipesBeingGenerated[recipe.Id] = true;
                }

                // Check favorites in batch for all recipes
                await CheckFavoritesBatch();
            }
        }
        catch
        {
            Snackbar.Add("Impossible de charger le menu. Veuillez réessayer.", Severity.Error);
        }
        finally
        {
            _loading = false;
        }
    }

    private async Task CheckFavoritesBatch()
    {
        if (_menu == null || !_menuValid || !_menu.Recipes.Any())
            return;

        try
        {
            var request = new CheckDuplicatesBatchRequest
            {
                Recipes = _menu.Recipes.Select(r => new RecipeCheckItem
                {
                    RecipeId = r.Id,
                    Title = r.Title,
                    Ingredients = r.Ingredients.Select(i => new IngredientRequest
                    {
                        Name = i.Name,
                        Quantity = i.Quantity,
                        Category = i.Category
                    }).ToList()
                }).ToList()
            };

            var response = await FavoriteApi.CheckDuplicatesBatchAsync(request);
            
            // Build dictionary of favorite status for all recipes
            // Initialize all recipes to false first, then set to true if they match
            foreach (var recipe in _menu.Recipes)
            {
                _favoriteStatus[recipe.Id] = response.Matches.Any(m => m.RecipeId == recipe.Id);
            }
        }
        catch
        {
            // Log error but don't block the UI - RecipeCard will fallback to individual checks
            // In production, you might want to log this
        }
    }

    private async Task<bool> VerifyMenuValid()
    {
        try
        {
            await ShoppingListApi.GetShoppingListAsync(MenuId);
            return true; // If the list exists, the menu is validated
        }
        catch
        {
            return false; // If error (probably 404), the menu is not yet validated
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection is not null)
        {
            try
            {
                await _hubConnection.StopAsync();
            }
            catch
            {
                // Ignore errors during shutdown
            }
            finally
            {
                await _hubConnection.DisposeAsync();
            }
        }
    }

    private async Task OpenAddFavoriteDialog()
    {
        var parameters = new DialogParameters<AddFavoriteDialog>
        {
            { x => x.MenuId, MenuId }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Medium,
            FullWidth = true,
            CloseButton = true
        };

        var dialog = await DialogService.ShowAsync<AddFavoriteDialog>("Ajouter un plat favori", parameters, options);
        var result = await dialog.Result;

        if (result != null && !result.Canceled)
        {
            await LoadMenu();
            // Recheck favorites after adding a new favorite
            await CheckFavoritesBatch();
        }
    }

    private async Task DeleteRecipe(int recipeId)
    {
        var parameters = new DialogParameters<ConfirmDialog>
        {
            { x => x.Title, "Supprimer le plat" },
            { x => x.Message, "Êtes-vous sûr de vouloir supprimer ce plat du menu ? Les ingrédients seront également retirés de la liste de courses." },
            { x => x.ConfirmText, "Supprimer" },
            { x => x.CancelText, "Annuler" },
            { x => x.Color, Color.Error }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Small,
            FullWidth = true
        };

        var dialog = await DialogService.ShowAsync<ConfirmDialog>("Confirmation", parameters, options);
        var result = await dialog.Result;

        if (result != null && !result.Canceled)
        {
            try
            {
                await MenuApi.DeleteRecipeAsync(MenuId, recipeId);
                Snackbar.Add("Plat supprimé du menu", Severity.Success);
                await LoadMenu();
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Erreur lors de la suppression : {ex.Message}", Severity.Error);
            }
        }
    }

    private async Task ToggleRecipeCooked(int recipeId)
    {
        try
        {
            var updatedRecipe = await MenuApi.ToggleRecipeCookedStatusAsync(MenuId, recipeId);
            
            // Update the recipe in the menu
            if (_menu != null)
            {
                var index = _menu.Recipes.FindIndex(r => r.Id == recipeId);
                if (index >= 0)
                {
                    _menu.Recipes[index] = updatedRecipe;
                }
            }

            var message = updatedRecipe.IsCooked 
                ? "Plat marqué comme cuisiné" 
                : "Plat non marqué comme cuisiné";
            Snackbar.Add(message, Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Erreur lors de la mise à jour : {ex.Message}", Severity.Error);
        }
    }

    private void ViewShoppingList(int menuId)
    {
        Navigation.NavigateTo($"/shopping-list/{menuId}");
    }
}

