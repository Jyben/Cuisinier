@page "/menu-generation/{MenuId:int}"
@attribute [Microsoft.AspNetCore.Authorization.Authorize]
@using Cuisinier.App.Components
@using Cuisinier.App.Services
@using Cuisinier.Shared.DTOs
@using MudBlazor
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.Extensions.Logging
@inject IMenuApi MenuApi
@inject IShoppingListApi ShoppingListApi
@inject NavigationManager Navigation
@inject IConfiguration Configuration
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject ILogger<MenuGeneration> Logger
@implements IAsyncDisposable

<PageTitle>Génération du menu</PageTitle>

@if (_loading)
{
    <MudProgressLinear Color="Color.Primary" Indeterminate="true" />
}

@if (_isValidating)
{
    <LoadingAnimation 
        Title="Génération de la liste de courses en cours..." 
        Subtitle="Veuillez patienter pendant la création de votre liste" />
}

@if (_menu != null && !_isValidating)
{
    var menuTitle = $"Menu - Semaine du {_menu.WeekStartDate:dd/MM/yyyy}";
    <PageHeader Title="@menuTitle" />

    <MudGrid>
        @foreach (var recipe in _menu.Recipes)
        {
            <MudItem xs="12" md="6" lg="4">
                <RecipeCard 
                    Recipe="recipe" 
                    ShowActions="true" 
                    ShowFavoriteButton="false"
                    OnDelete="DeleteRecipe" 
                    OnReplace="ReplaceRecipe"
                    IsGenerating="@IsGenerating(recipe.Id)"
                    IsReplacing="@IsReplacing(recipe.Id)"
                    MenuValid="@_menuValid" />
            </MudItem>
        }
        @foreach (var dish in _pendingDishes)
        {
            <MudItem xs="12" md="6" lg="4">
                <RecipeCard
                    Recipe="@ConvertDishToRecipe(dish)"
                    ShowActions="true"
                    ShowFavoriteButton="false"
                    OnDelete="@(() => RemovePendingDish(dish.Id))"
                    OnReplace="@(() => {})"
                    IsGenerating="false"
                    MenuValid="@_menuValid" />
            </MudItem>
        }
        @if (!_menuValid)
        {
            <MudItem xs="12" md="6" lg="4">
                <AddDishCard OnAddClick="OpenAddDishDialog" />
            </MudItem>
        }
    </MudGrid>

    @if (!_menuValid)
    {
        <MudStack Row="true" Spacing="3" Justify="Justify.FlexStart" Class="mt-4 action-buttons-container">
            <MudButton 
                Variant="Variant.Filled" 
                Color="Color.Primary" 
                Size="Size.Large"
                OnClick="ValidateMenu"
                StartIcon="@Icons.Material.Filled.CheckCircle"
                Disabled="@_isValidating"
                Class="validate-button">
                Valider le menu
            </MudButton>
            <MudButton 
                Variant="Variant.Outlined" 
                Color="Color.Error" 
                Size="Size.Large"
                OnClick="DeleteAll"
                StartIcon="@Icons.Material.Filled.Delete"
                Class="delete-all-button">
                Tout supprimer
            </MudButton>
        </MudStack>
    }
}

@code {
    [Parameter] public int MenuId { get; set; }

    private MenuResponse? _menu;
    private bool _loading = true;
    private bool _isValidating = false;
    private bool _menuValid = false;
    private HubConnection? _hubConnection;
    private Dictionary<int, bool> _recipesBeingGenerated = new();
    private Dictionary<int, bool> _recipesBeingReplaced = new();
    private int? _lastConnectedMenuId = null;
    private List<DishResponse> _pendingDishes = new();

    protected override async Task OnInitializedAsync()
    {
        await LoadMenu();
        await InitializeSignalR();
    }

    protected override async Task OnParametersSetAsync()
    {
        // If MenuId changes or if we are not connected, reload the menu and reconnect SignalR
        if (_menu?.Id != MenuId || _lastConnectedMenuId != MenuId || _hubConnection?.State != HubConnectionState.Connected)
        {
            await LoadMenu();
            await InitializeSignalR();
        }
    }

    private async Task InitializeSignalR()
    {
        // Close existing connection if it exists
        if (_hubConnection is not null)
        {
            try
            {
                await _hubConnection.StopAsync();
                await _hubConnection.DisposeAsync();
            }
            catch
            {
                // Ignore errors during shutdown
            }
            _hubConnection = null;
        }

        var apiBaseUrl = Configuration["ApiBaseUrl"] ?? Navigation.BaseUri;
        var hubUrl = $"{apiBaseUrl.TrimEnd('/')}/recipeHub";

        _hubConnection = new HubConnectionBuilder()
            .WithUrl(hubUrl)
            .WithAutomaticReconnect()
            .Build();

        _hubConnection.On<RecipeResponse>("RecipeDetailedGenerated", (recipe) =>
        {
            if (_menu != null)
            {
                var index = _menu.Recipes.FindIndex(r => r.Id == recipe.Id);
                if (index >= 0)
                {
                    _menu.Recipes[index] = recipe;
                    _recipesBeingGenerated[recipe.Id] = false;
                    InvokeAsync(StateHasChanged);
                }
            }
        });

        _hubConnection.On<int>("RecipeGenerationError", (recipeId) =>
        {
            _recipesBeingGenerated[recipeId] = false;
            InvokeAsync(StateHasChanged);
        });

        // Handle reconnection - refetch data after reconnecting
        _hubConnection.Reconnected += async (connectionId) =>
        {
            Logger.LogInformation("SignalR reconnected. Rejoining menu group and refreshing data.");
            try
            {
                await _hubConnection.SendAsync("JoinMenuGroup", MenuId);
                await InvokeAsync(async () =>
                {
                    await RefreshRecipesState();
                    StateHasChanged();
                });
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error during SignalR reconnection handling");
            }
        };

        try
        {
            await _hubConnection.StartAsync();
            await _hubConnection.SendAsync("JoinMenuGroup", MenuId);
            _lastConnectedMenuId = MenuId;

            // After joining, refetch to catch any updates we might have missed
            await RefreshRecipesState();
        }
        catch
        {
            Snackbar.Add($"Erreur de connexion SignalR. Veuillez réessayer.", Severity.Error);
            _lastConnectedMenuId = null;
        }
    }

    private async Task RefreshRecipesState()
    {
        try
        {
            var freshMenu = await MenuApi.GetMenuAsync(MenuId);
            if (freshMenu != null && _menu != null)
            {
                foreach (var freshRecipe in freshMenu.Recipes)
                {
                    var index = _menu.Recipes.FindIndex(r => r.Id == freshRecipe.Id);
                    if (index >= 0)
                    {
                        _menu.Recipes[index] = freshRecipe;
                        // If recipe now has DetailedRecipe, mark as not generating
                        if (!string.IsNullOrEmpty(freshRecipe.DetailedRecipe))
                        {
                            _recipesBeingGenerated[freshRecipe.Id] = false;
                        }
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to refresh recipes state");
        }
    }

    private bool IsGenerating(int recipeId)
    {
        // Only return true if explicitly marked as generating in the dictionary
        return _recipesBeingGenerated.TryGetValue(recipeId, out var isGenerating) && isGenerating;
    }

    private bool IsReplacing(int recipeId)
    {
        return _recipesBeingReplaced.ContainsKey(recipeId) && _recipesBeingReplaced[recipeId];
    }

    private async Task LoadMenu()
    {
        try
        {
            _loading = true;
            _menu = await MenuApi.GetMenuAsync(MenuId);

            // Check if the menu has been validated (if a shopping list exists)
            _menuValid = await VerifyMenuValid();

            // Clear state when reloading
            _recipesBeingGenerated.Clear();
            _recipesBeingReplaced.Clear();

            // Mark recipes without DetailedRecipe as being generated (only for validated menus)
            // The cache is properly invalidated server-side, so we get fresh data
            // SignalR events will update the state when generation completes
            if (_menu != null && _menuValid)
            {
                foreach (var recipe in _menu.Recipes.Where(r => string.IsNullOrEmpty(r.DetailedRecipe)))
                {
                    _recipesBeingGenerated[recipe.Id] = true;
                }
            }
        }
        catch
        {
            Snackbar.Add("Impossible de charger le menu. Veuillez réessayer.", Severity.Error);
        }
        finally
        {
            _loading = false;
        }
    }

    private async Task<bool> VerifyMenuValid()
    {
        try
        {
            await ShoppingListApi.GetShoppingListAsync(MenuId);
            return true; // If the list exists, the menu is validated
        }
        catch
        {
            return false; // If error (probably 404), the menu is not yet validated
        }
    }

    private async Task DeleteRecipe(int recipeId)
    {
        // If recipeId is negative, it's a pending dish
        if (recipeId < 0)
        {
            RemovePendingDish(-recipeId);
            return;
        }

        try
        {
            await MenuApi.DeleteRecipeAsync(MenuId, recipeId);
            await LoadMenu();
        }
        catch
        {
            Snackbar.Add("Impossible de supprimer la recette. Veuillez réessayer.", Severity.Error);
        }
    }

    private async Task ReplaceRecipe(int recipeId)
    {
        try
        {
            // Mark recipe as being replaced
            _recipesBeingReplaced[recipeId] = true;
            StateHasChanged();

            // Get the last parameters used for menu generation
            var parameters = await MenuApi.GetLastParametersAsync();
            if (parameters == null)
            {
                _recipesBeingReplaced[recipeId] = false;
                StateHasChanged();
                Snackbar.Add("Impossible de récupérer les paramètres du menu. Veuillez réessayer.", Severity.Error);
                return;
            }

            var request = new RecipeReplacementRequest
            {
                Parameters = parameters
            };

            await MenuApi.ReplaceRecipeAsync(MenuId, recipeId, request);
            
            // Reload the menu to show the new recipe (this will clear the replacing state)
            await LoadMenu();
            
            Snackbar.Add("Plat remplacé avec succès.", Severity.Success);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error replacing recipe {RecipeId}", recipeId);
            _recipesBeingReplaced[recipeId] = false;
            StateHasChanged();
            Snackbar.Add("Impossible de remplacer le plat. Veuillez réessayer.", Severity.Error);
        }
    }

    private async Task ValidateMenu()
    {
        try
        {
            _isValidating = true;
            StateHasChanged();

            // Mark recipes without details as being generated
            if (_menu != null)
            {
                foreach (var recipe in _menu.Recipes.Where(r => string.IsNullOrEmpty(r.DetailedRecipe)))
                {
                    _recipesBeingGenerated[recipe.Id] = true;
                }
            }

            var request = new ValidateMenuRequest
            {
                FavoriteIds = new List<int>(),
                DishIds = _pendingDishes.Select(d => d.Id).ToList()
            };

            await MenuApi.ValidateMenuAsync(MenuId, request);
            Navigation.NavigateTo($"/shopping-list/{MenuId}");
        }
        catch
        {
            _isValidating = false;
            StateHasChanged();
            Snackbar.Add("Impossible de valider le menu. Veuillez réessayer.", Severity.Error);
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection is not null)
        {
            try
            {
                await _hubConnection.StopAsync();
            }
            catch
            {
                // Ignore errors during shutdown
            }
            finally
            {
                await _hubConnection.DisposeAsync();
            }
        }
    }

    private async Task OpenAddDishDialog()
    {
        var parameters = new DialogParameters<AddDishDialog>
        {
            { x => x.MenuId, MenuId },
            { x => x.IsPendingMode, true }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Large,
            FullWidth = true,
            CloseButton = true
        };

        var dialog = await DialogService.ShowAsync<AddDishDialog>("Ajouter un plat", parameters, options);
        var result = await dialog.Result;

        if (result != null && !result.Canceled && result.Data is DishResponse dish)
        {
            if (!_pendingDishes.Any(d => d.Id == dish.Id))
            {
                _pendingDishes.Add(dish);
                StateHasChanged();
            }
        }
    }

    private void RemovePendingDish(int dishId)
    {
        _pendingDishes.RemoveAll(d => d.Id == dishId);
        StateHasChanged();
    }

    private RecipeResponse ConvertDishToRecipe(DishResponse dish)
    {
        return new RecipeResponse
        {
            Id = -dish.Id, // Negative ID to distinguish from real recipes
            MenuId = MenuId,
            Title = dish.Title,
            Description = dish.Description,
            CompleteDescription = dish.CompleteDescription,
            DetailedRecipe = dish.DetailedRecipe,
            ImageUrl = dish.ImageUrl,
            PreparationTime = dish.PreparationTime,
            CookingTime = dish.CookingTime,
            Kcal = dish.Kcal,
            Servings = dish.Servings,
            Ingredients = dish.Ingredients.Select(i => new IngredientResponse
            {
                Id = i.Id,
                Name = i.Name,
                Quantity = i.Quantity,
                Category = i.Category
            }).ToList(),
            IsFromDatabase = true,
            OriginalDishId = dish.Id
        };
    }

    private async Task DeleteAll()
    {
        try
        {
            await MenuApi.DeleteMenuAsync(MenuId);
            Navigation.NavigateTo("/");
        }
        catch
        {
            Snackbar.Add("Impossible de supprimer le menu. Veuillez réessayer.", Severity.Error);
        }
    }
}

<style>
    .action-buttons-container {
        padding-top: 1rem;
        border-top: 1px solid var(--mud-palette-lines-default, rgba(0,0,0,0.12));
    }

    .validate-button {
        text-transform: none;
        font-weight: 600;
        letter-spacing: 0.3px;
        padding: 0.75rem 2rem;
    }

    .delete-all-button {
        text-transform: none;
        font-weight: 500;
        letter-spacing: 0.3px;
        padding: 0.75rem 2rem;
    }
</style>

